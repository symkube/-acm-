###开赛历程###

>>开始时
调到最高版本的cpp！
打开全部 warning！
①: 签到题可能没读完题就写完了,需要交叉读完题目看细节 (尤其是 无解\不连通 输出-1之类的情况 , 1 0 0这种边界数据)
②: 快速翻题, 有没有数据范围特别怪异的 (有没有北大的喵)
③: 前期题奇妙算法(二分/贪心/各种O(n)做法)的时候交叉检验二分/贪心/图性质是否是真的

>>菜鸡的中后期自闭阶段
①:把所有题目概览一遍, 经常会有水题没人发现/模板题别人不会. (被A穿的例子:南京现场概率题, 如果没几个人过, 大概也没什么胆敢大力猜结论的; 被卡爆的例子: 树上路径众数/南京现场机器人构造路径/沈阳E线段树/19南京现场排列组合)
②:大块改代码时注意数据范围有没有错
③:自闭加特判的时候, 对边界的特判, 如果有两维边界, 对一位的边界特判时考虑另一维的影响

>>计算几何
①:三角形/四边形的退化情况
②:线段与多边形交的各种情况
>>按位处理
①:按位处理的时候 , 即便题目的位数很小 , 可能也要考虑更高的位
>>建图
①:500个人500个怪要开1000个点
>>卡常
①:前向星会被cache暴打(用vector)
②:spfa之类的可以随机化/手动改变遍历顺序, 反杀毒瘤出题人
>>二分
①:是否涉及了负数除以二（int相当于默认向0取整）


###写题时的正常操作###

>>开题时
①:先看数据范围炸不炸int/long long (注意1e5相乘/1e9相加相乘)
②:数组大小设置成maxn之类的方便调试

>>初始化
①:需要多倍空间时是不是只初始化了一倍(线段树)
②:乘法逆元的预处理
③:预处理的时候是否需要取mod

>>数据范围
①:值域炸int/longlong
②:中间过程的常数运算要用ll, 尤其是按位枚举之类的位运算要左移右移1ll
③:输入输出时scanf/read() 与数据范围有没有对应
④:1e6 用 unordered_map

>>输出
①:ll的输出有没有打错
②:printf输出格式的小数点位数
③:乘法逆元/普通mod的输出(+p %p)

>>提交代码时
①:freopen有没有删
②:memset是不是按字节的
③:再次计算min/max的初始化够不够cover值域
④:乘法逆元/普通mod的输出(+p %p)
⑤:输出格式是否特殊要求了行末空格段末回车,包括

>>自闭调不出来时
①:边界情况, 不连通/无解时的特判(0 1 1)
②:对边界的特判, 如果有两维边界, 对一位的边界特判时考虑另一维的影响
③:数组嵌套调用的时候有没有漏掉一层(小数据容易恰好没问题)(  x->lson->rson  <=>  rson[lson[x]]  )
④:TLE不要先想着卡常orz, 优先考虑算法问题甚至越界之类的


#签到题可能没读完题就写完了,需要完成读完题目看细节, 尤其是无解\不连通输出-1
#先看数据范围炸不炸ll
#位运算的1ll
#printf没加lld，中间过程的ll、加了东西之后的ll
#1e9的相加、相乘
#printf输出格式的"."
#数组大小设置参数
#long long有没有打全
#没删freopen
#memset用memset的inf  !!!!
#min不够小 , 
#需要多倍空间的时候，初始化只初始化了一倍*线段树的空间
#要求 输出模之后ans，ans要再除以二或者加一减一时保证模的正确性
#预处理、存东西的时候别忘mod
#有没有初始化
#有没有爆栈
#输出格式（换行、空格、）
#三角形、直线的退化
#最后除以某个数字x是不是模意义下的逆元
#有两个边界的情况下不要只特判一个边界
#数组嵌套调用时是不是丢了一层
#1e6用unordered_map
#按位处理的时候 , 即便题目的位数很小 , 可能也要考虑更高的位
#500个人500个怪要开1000个点
#前期题奇妙算法(二分/贪心/各种O(n)做法)的时候交叉检验二分/贪心/图性质是否是真的
#TLE不要先想着卡常orz
#前向星被cache暴打
