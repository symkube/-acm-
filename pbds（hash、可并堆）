什么是__gnu_pbds?Policy based data structures！简称平板电视pbds。在使用pbds前，你需要：

#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>//用tree
#include<ext/pb_ds/hash_policy.hpp>//用hash
#include<ext/pb_ds/trie_policy.hpp>//用trie
#include<ext/pb_ds/priority_queue.hpp>//用priority_queue
using namespace __gnu_pbds;

woc，真jb烦，有没有什么简单的方法？当然有：

#include<bits/extc++.h>
using namespace __gnu_pbds;
//bits/extc++.h与bits/stdc++.h类似，bits/extc++.h是所有拓展库，bits/stdc++.h是所有标准库

但是在dev c++里如果这样写，会提示少一个文件，出各种莫名奇妙的锅，其它的IDE请自行尝试，我的linux是deepin的，装了NOI Linux的dalao帮忙测一下。


《hash表》

hash_table的用法与map类似，它是这么定义的：

cc_hash_table<int,bool> h;
gp_hash_table<int,bool> h;

其中cc开头为拉链法，gp开头为探测法，个人实测探测法稍微快一些。

啥？操作？其实就和map差不多，支持[ ]和find。

#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
gp_hash_table<string,int> h;
void judge(string s)
{
    if(h.find(s)!=h.end())
        cout<<"orz %%%";
    else
        cout<<"tan90";
    cout<<endl;
}
int main()
{
    h["Ican'tAKIOI"]=1;
    h.insert(make_pair("UAKIOI",1));
    string str;
    while(cin>>str)
        judge(str);
    return 0;
}


《可并堆》
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;
using namespace __gnu_pbds;
typedef __gnu_pbds::priority_queue <pair<int, int>, greater<pair<int, int> >, pairing_heap_tag> heap;
heap q;
提供以下函数：：

priority_queue()默认构造函数
priority_queue(const priority_queue &other) 用另一个优先队列来构造
size()用法同std
empty()用法同std
push(const_reference r_val)注意push返回point_iterator
top()没区别…
pop()没什么好说的
point_iterator对应某元素的迭代器
erase(point_iterator it)删除对应点
modify(point_iterator it,const_reference r_new_val)修改对应点的值(这是优化dijkstra神方法,均摊复杂度O(1))
clear()基本没什么用,还不如重新定义一个…
join(priority_queue &other)神方法*2,白送可并堆啊,还是O(1)的,注意合并后other会被清空
split(Pred prd,priority_queue &other)拆分,但好像没什么用
其他迭代器同std
